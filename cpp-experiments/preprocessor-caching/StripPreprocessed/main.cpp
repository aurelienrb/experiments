#include <fstream>
#include <string>
#include <iostream>
#include <cassert>

using namespace std;

inline bool is_separator(char c) {
	return c == ' ' || c == '\t';
}

void trim_trailing(string & str) {
	size_t endpos = str.find_last_not_of(" \t");
	if (string::npos != endpos) {
		str.resize(endpos + 1);
	}
}

void test() {
	string s("a b\tc \t ");
	trim_trailing(s);
	assert(s == "a b\tc");
}

class save_previous_char {
public:
	save_previous_char(char & previous, char current) : m_previous(previous), m_current(current) {
	}
	~save_previous_char() {
		m_previous = m_current;
	}
private:
	char & m_previous;
	char m_current;
};

bool can_merge_with_next_line(const std::string & line) {
	assert(!line.empty());

	switch (line.back()) {
		case '{':
		case '}':
		case ';':
		case ':':
			return false;
	}
	return true;
}

bool is_symbol_name_char(char c) {
	return (c >= 'a' && c <= 'z') ||
		(c >= 'A' && c <= 'Z') ||
		(c >= '0' && c <= '9') ||
		(c == '_');
}

// remove comments and other blank lines in the preprocessor output of VC++
// expected input: the file generated by "cl.exe /P /C /TP example.h"
int main(int argc, char *argv[]) {
	test();

	if (argc < 2) {
		cout << "Missing argument\n";
		return 1;
	}

	ifstream input(argv[1]);
	if (!input) {
		return 1;
	}

	ofstream output(string(argv[1]) + ".h");
	if (!output) {
		return 1;
	}

	string line;
	string new_line;
	bool inside_comment = false;
	bool inside_asm_block = false;

	while (getline(input, line)) {
		if (!inside_comment) {
			auto pos = line.find_first_not_of(" \t");
			if (pos == string::npos) {
				pos = 0;
			}
			if (line.substr(pos, 6) == "#line ") {
				continue;
			}
			if (line.substr(pos, 12) == "#pragma once") {
				continue;
			}
		}

		new_line.clear();
		char previous_char = '\0';
		bool inside_string = false;

		for (char c : line) {
			save_previous_char saver(previous_char, c);

			// skip first separators
			if (new_line.empty() && is_separator(c)) {
				continue;
			}

			if (inside_comment) {
				// skip multi-line comments
				if (previous_char == '*' && c == '/') {
					inside_comment = false;
				}
				continue;
			}
			else if (c == '"') {
				if (!inside_string) {
					inside_string = true;
				} else if (previous_char != '\\') {
					inside_string = false;
				}
			}
			else if (!inside_string) {
				if (previous_char == '/') {
					// skip single line comments
					if (c == '/') {
						if (!new_line.empty()) {
							new_line.resize(new_line.size() - 1);
						}
						break;
					}
					if (c == '*') {
						if (!new_line.empty()) {
							new_line.resize(new_line.size() - 1);
						}
						inside_comment = true;
						continue;
					}
				}
				else {
					if (is_separator(c)) {
						// skip separators repetition
						if (is_separator(previous_char)) {
							continue;
						}
						if (!new_line.empty()) {
							switch (new_line.back()) {
							case '(':
							case '<':
							case ',':
							case '[':
							case '{':
							case ')':
							case '>':
							case ']':
							case '}':
								continue;
							}
						}
					}
					else if (new_line.size() >= 2 && is_separator(new_line.back())) {
						// remove previous separator if useless
						char before_separator = new_line[new_line.size() - 2];
						switch (c) {
						case '(':
						case '<':
						case ',':
						case '[':
						case '{':
						case ')':
						case '>':
						case ']':
						case '}':
							new_line.back() = c;
							continue;
						}
					}
				}
			}
			new_line += c;
		}

		trim_trailing(new_line);

		if (new_line.empty()) {
			continue;
		}
		assert(!is_separator(new_line[0]));

		// need to go to new line for this line?
		bool force_cr = (new_line.front() == '#');

		if (!inside_asm_block) {
			if (new_line.find("__asm") != string::npos) {
				bool has_block_begin = (new_line.find('{') != string::npos);
				bool has_block_end = (new_line.find('}') != string::npos);
				inside_asm_block = (has_block_begin && !has_block_end);
				force_cr = true;
			}
		}
		else { // inside __asm {}
			bool has_block_end = (new_line.find('}') != string::npos);
			inside_asm_block = !has_block_end;
		}

		if (force_cr) {
			output << '\n';
		}
		output << new_line;
		if (!force_cr && !inside_asm_block && can_merge_with_next_line(new_line)) {
			output << ' ';
		}
		else {
			output << '\n';
		}
	}
}